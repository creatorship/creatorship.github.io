<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半 岛</title>
  
  <subtitle>Quick notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bandao.ink/"/>
  <updated>2018-11-26T00:59:43.007Z</updated>
  <id>http://bandao.ink/</id>
  
  <author>
    <name>JF</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FreeMarker学习笔记</title>
    <link href="http://bandao.ink/2018/11/25/FreeMarker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://bandao.ink/2018/11/25/FreeMarker学习笔记/</id>
    <published>2018-11-25T10:37:29.000Z</published>
    <updated>2018-11-26T00:59:43.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>从毕业到现在，从事的项目基本都是前后端分离项目，当然了这也是大势所趋。然而时间一长，发现自己View层的能力愈发欠缺，于是乎就找了FreeMarker这种对spring boot天生支持良好的模版引擎充电。</p></blockquote><h2 id="理解模版引擎"><a href="#理解模版引擎" class="headerlink" title="理解模版引擎"></a>理解模版引擎</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>借用官方的解释：FreeMarker 是一款 <em>模板引擎</em>： 即一种基于模板和要改变的数据， 并用来生成输出文本的通用工具。</p><p>FreeMarker后缀是.ftl的文件，它是Java的一个类库，View层的一个组件，一般用于生产html</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f2.png" alt="images"></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>其实简单来讲大致的流程是这样的：</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f3.png" alt="images"></p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>pom引入依赖如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>目录结构</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f4.png" alt="images"></p><ul><li>src源代码目录</li><li>static静态资源目录</li><li>templates即.ftl文件目录</li></ul><h3 id="两个简单的demo"><a href="#两个简单的demo" class="headerlink" title="两个简单的demo"></a>两个简单的demo</h3><p>如今的spring boot自动化配置时代，许多事情都变得简单了起来。spring boot规定只要将.ftl文件丢到templates包下，在控制层返回.ftl文件的名字即可生成html返回给浏览器</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f5.png" alt="images"></p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f6.png" alt="images"></p><ul><li>启动项目访问浏览器即可看到效果</li></ul><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f7.png" alt="images"></p><p>再来看看一个简单的传值</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f8.png" alt="images"></p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f10.png" alt="images"></p><ul><li>输出结果</li></ul><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f9.png" alt="images"></p><p>这里借用一下官网解释，FreeMarker这个模版引擎是由下面几部分混合而成</p><ul><li><strong>文本</strong>：文本会照着原样来输出。</li><li><strong>插值</strong>：这部分的输出会被计算的值来替换。插值由 <code>${</code> and <code>}</code> 所分隔(或者 <code>#{</code> and <code>}</code>，这种风格已经不建议再使用了；<a href="http://freemarker.foofun.cn/ref_depr_numerical_interpolation.html" target="_blank" rel="noopener">点击查看更多</a>)。</li><li><strong>FTL 标签</strong>【指令】：FTL标签和HTML标签很相似，但是它们却是给FreeMarker的指示， 而且不会打印在输出内容中。</li><li><strong>注释</strong>：注释和HTML的注释也很相似，但它们是由 <code>&lt;#--</code> 和 <code>--&gt;</code>来分隔的。注释会被FreeMarker直接忽略， 更不会在输出内容中显示。</li></ul><p>我们来看一个具体的模板。其中的内容已经用颜色来标记了： 文本【蓝】， 插值【橘】， FTL 标签【黄】， 注释【绿】</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f11.png" alt="images"></p><p>下面再来理解这张图应该就好理解了吧</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/fm/f1.png" alt="images"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这篇就先入个门吧，FreeMarker是由很多高级特性的。后面有空再专门写一篇自定义函数、自定义指令的文章吧。</p></blockquote><p>备用：<a href="http://freemarker.foofun.cn/" target="_blank" rel="noopener">官方手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从毕业到现在，从事的项目基本都是前后端分离项目，当然了这也是大势所趋。然而时间一长，发现自己View层的能力愈发欠
      
    
    </summary>
    
      <category term="Java" scheme="http://bandao.ink/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://bandao.ink/categories/Java/FreeMarker/"/>
    
    
      <category term="FreeMarker" scheme="http://bandao.ink/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://bandao.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程的讨论</title>
    <link href="http://bandao.ink/2018/11/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
    <id>http://bandao.ink/2018/11/22/进程和线程的讨论/</id>
    <published>2018-11-22T06:24:29.000Z</published>
    <updated>2018-11-22T08:04:22.354Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这段时间公司比较闲。出来也两年多了，代码敲地越多，越觉得基础知识有多重要，嘛，闲来无事儿随便捣鼓捣鼓充哈电。</p></blockquote><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><strong>进程：</strong>是具有一定独立功能的程序，进程是系统资源分配的一个独立单元。</li><li><strong>线程：</strong>线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源(内存)。在运行时，只是暂用一些计数器、寄存器和栈 。</li><li><strong>关系：</strong>一个进程是一个或多个线程的容器</li></ul><p>呃，这样说起来可能还是很模糊。</p><p>简单的讲，系统分配资源（内存）的对象是进程，进程外有一层强制隔离的壳，A进程是没有办法访问到B进程的内存的，如果进程之间要进行通信，就必须使用外部手段比如Socket通信等。而真正执行CPU计算任务的是一个又一个线程，线程之间的通信很方便，同一进程下的线程共享全局变量、静态变量等数据- - 我的理解是这样哈，不知道对不对。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>现在有一个软件外包公司（虽然我没去过外包公司，逃）</p><ul><li><strong>CPU：</strong>外包公司，它就是计算机的CPU，承担了所有计算任务。比如对接新项目、判断是否超过公司能力、计算项目成本、预估项目周期、分派给<strong>合适的项目组</strong>、实施开发、交付项目等等。它就像一个巨大的齿轮，时刻在工作运行。</li><li><strong>进程：</strong>进程就好比项目组，它代表CPU能处理的单个任务。每个项目组能独立地运作，实施独立的工程。</li><li><strong>线程：</strong>线程就是程序猿们，就是具体的一个实体。当然一只猿也可以叫做一个项目组。公司派的任务是分配的项目组的，而具体落实实施的是猿。</li><li><strong>进程间的通信：</strong>首先我们要知道，进程和进程间的内存是很难共享的。比如项目组A有5个程序员，项目组B有10个程序员。项目A的程序员不可能是撸项目B的代码吧，因为你没有项目B代码的git权限。当然如果你实在优秀非要两个项目都做，那么就必须经过XXX协商(进程通信比如Socket)，满足两个项目组的约定后方可进入另一个项目组执行任务。</li><li><strong>线程间的通信：</strong>线程间的通信就简单多了，线程间的数据是非常好共享的。项目组A下面的各个程序员本身在一个组里，我可以看到你提交的代码，你可以看到我提交的代码。</li><li><strong>互斥锁：</strong>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。比如公司的洗手间</li><li><strong>信号量：</strong>进程使用的内存地址可以限定使用量，这些内存地址只能给固定数量的线程使用。比如公司的会议室，最多只能允许20人进去开会，如果满了，就要等人出来才能进去。</li><li><strong>互相影响：</strong>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。比如说项目组A有个程序员猝死了，我不相信你特么还让其他4个人继续开发，项目组B还没有人猝死，OK继续工作（你是魔鬼吗）</li></ul><p>总结一下就是进程是线程的老大哥，管理着总多线程小老弟。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>这里容我无耻的转载一波</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/thread/lw.png" alt="images"></p><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>这篇文章感觉写的还是很浅薄。嘛，后面再补充吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这段时间公司比较闲。出来也两年多了，代码敲地越多，越觉得基础知识有多重要，嘛，闲来无事儿随便捣鼓捣鼓充哈
      
    
    </summary>
    
      <category term="线程" scheme="http://bandao.ink/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="http://bandao.ink/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>OSI七层模型及相关协议学习笔记</title>
    <link href="http://bandao.ink/2018/11/20/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://bandao.ink/2018/11/20/OSI七层模型及相关协议学习笔记/</id>
    <published>2018-11-20T08:00:29.000Z</published>
    <updated>2018-11-21T09:17:33.927Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>哎，本来今天是想写一篇关于go语言的学习笔记的，但是想想还是算了吧，本来自己领域里面的东西都还是半吊子，还是先把一门做深入了来吧 /摊手 。于是乎想起了之前上家公司用的dubbo和现在在做的spring cloud，两者的传输协议默认是rpc和http，要理解这两种协议，还得从OSI七层模型说起。记得当时在自考时还学过计算机网路原理这门科目，现在看来，真是考试完就忘了，重新系统的学一遍吧。</p></blockquote><h2 id="七层模型"><a href="#七层模型" class="headerlink" title="七层模型"></a>七层模型</h2><p>自底向上，物理层为最底层</p><table><thead><tr><th>OSI七层模型</th><th>功能</th><th>相关协议</th></tr></thead><tbody><tr><td>应用层</td><td>最终提供出来的接口。也就是终端应用，这一层是最直观展现给终端用户的。【比如浏览器，QQ】</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td>表示层</td><td>数据的表示、安全、压缩。将计算机识别的东西解析成人能识别的东西。【比如声音，图片】</td><td>Telnet, Rlogin, SNMP, Gopher</td></tr><tr><td>会话层</td><td>通过传输层建立数据传输通路实现建立、管理、终止回话。继而最终表现形式为，本地主机与远程主机会话【比如本地主机请求‘百度’本质上是本机ip请求‘百度’服务器ip，这种过程即为一次会话】</td><td>SMTP, DNS</td></tr><tr><td>传输层</td><td>定义了一些传输数据的协议和端口，如TCP和UDP，主要将下层接收的数据进行分段和传输，到达目的地址后进行重组，当数据包一旦离开以太网卡即进入网络传输层</td><td>TCP, UDP</td></tr><tr><td>网络层</td><td>选择合适的网间路由和交换结点，确保数据的即使传送，将从下层接收到的数据进行ip地址的封装和解封装。</td><td>IP, ICMP, ARP, RARP</td></tr><tr><td>数据链路层</td><td>主要将从物理层接收的数据进行MAC地址的封装和解封装。常把这一层的数据叫做帧，主要设备是网卡和交换机</td><td>FDDI，PPP，STP，帧中继</td></tr><tr><td>物理层</td><td>主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速度等，主要作用是传输bit流【二进制数据】</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802.</td></tr></tbody></table><ul><li>OSI模型对应TCP/IP模型</li></ul><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/osi/ot.jpeg" alt="images"></p><p>由上图，我们可以引出，在实际应用过程中，五层协议结构里面是没有表示层和会话层的，也就是说表示层和会话层合并成了应用层。所以平时我们为什么说RPC服务要比HTTP服务效率更高，是应为HTTP是属于应用层协议，RPC是属于传输层协议；就像存汇编要比Java快一个道理，因为人家更底层。</p><h2 id="RPC服务与HTTP服务"><a href="#RPC服务与HTTP服务" class="headerlink" title="RPC服务与HTTP服务"></a>RPC服务与HTTP服务</h2><blockquote><p>【备注】本节内容转载自CSDN</p><p>【原链接】<a href="https://blog.csdn.net/wangyunpeng0319/article/details/78651998" target="_blank" rel="noopener">https://blog.csdn.net/wangyunpeng0319/article/details/78651998</a></p><p>【原作者】wangyunpeng0319</p></blockquote><h3 id="RPC服务"><a href="#RPC服务" class="headerlink" title="RPC服务"></a>RPC服务</h3><p>从三个角度来介绍RPC服务：分别是RPC架构，同步异步调用以及流行的RPC框架。</p><h4 id="RPC架构"><a href="#RPC架构" class="headerlink" title="RPC架构"></a>RPC架构</h4><p>先说说RPC服务的基本架构吧。允许我可耻地盗一幅图哈~我们可以很清楚地看到，一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub，这个Stub大家可以理解为存根。分别说说这几个组件：</p><ul><li>客户端（Client），服务的调用方。</li><li>服务端（Server），真正的服务提供者。</li><li>客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><p><a href="https://obrxbqjbi.qnssl.com/blog/image/rpc-architecture.jpg" target="_blank" rel="noopener"><img src="https://obrxbqjbi.qnssl.com/blog/image/rpc-architecture.jpg" alt="img"></a></p><p>RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的<code>interface</code>），然后将整个项目打包为一个<code>jar</code>包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的<code>jar</code>包大小，因为每一次打包发布的时候，<code>jar</code>包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p><h4 id="同步异步调用"><a href="#同步异步调用" class="headerlink" title="同步异步调用"></a>同步异步调用</h4><p>什么是同步调用？什么是异步调用？<code>同步调用</code>就是客户端等待调用执行完成并返回结果。<code>异步调用</code>就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的<code>callable</code>和<code>runnable</code>接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用<code>callable</code>接口，并且可以通过<code>Future</code>类获取到异步执行的结果信息。如果不关心执行的结果，直接使用<code>runnable</code>接口就可以了，因为它不返回结果，当然啦，<code>callable</code>也是可以的，我们不去获取<code>Future</code>就可以了。</p><h4 id="流行的RPC框架"><a href="#流行的RPC框架" class="headerlink" title="流行的RPC框架"></a>流行的RPC框架</h4><p>目前流行的开源RPC框架还是比较多的。下面重点介绍三种：</p><ol><li>gRPC是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。</li><li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li><li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</li></ol><p><code>偷偷告诉你</code>集团内部已经不怎么使用dubbo啦，现在用的比较多的叫HSF，又名“好舒服”。后面有可能会开源，大家拭目以待。</p><h3 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h3><p>其实在很久以前，我对于企业开发的模式一直定性为HTTP接口开发，也就是我们常说的RESTful风格的服务接口。的确，对于在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。我们记得之前本科实习在公司做后台开发的时候，主要就是进行接口的开发，还要写一大份接口文档，严格地标明输入输出是什么？说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。比如下面这个例子：<br><code>POST http://www.httpexample.com/restful/buyer/info/share</code><br>接口可能返回一个JSON字符串或者是XML文档。然后客户端再去处理这个返回的信息，从而可以比较快速地进行开发。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p><h3 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h3><blockquote><p>【备注】本节内容转载自简书</p><p>【原链接】<a href="https://www.jianshu.com/p/b61695e6b473" target="_blank" rel="noopener">https://www.jianshu.com/p/b61695e6b473</a></p><p>【原作者】JouyPub</p></blockquote><ul><li><p>传输协议 </p><ul><li>RPC，可以基于TCP协议，也可以基于HTTP协议</li><li>HTTP，基于HTTP协议</li></ul></li><li><p>传输效率</p><ul><li>RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率</li><li>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理</li></ul></li><li>性能消耗，主要在于序列化和反序列化的耗时<ul><li>RPC，可以基于thrift实现高效的二进制传输</li><li>HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</li></ul></li><li>负载均衡<ul><li>RPC，基本都自带了负载均衡策略</li><li>HTTP，需要配置Nginx，HAProxy来实现</li></ul></li><li>服务治理（下游服务新增，重启，下线时如何不影响上游调用者）<ul><li>RPC，能做到自动通知，不影响上游</li><li>HTTP，需要事先通知，修改Nginx/HAProxy配置</li></ul></li></ul><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><blockquote><p>【备注】本节内容转载自阿里云</p><p>【原链接】<a href="https://www.aliyun.com/jiaocheng/1367320.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/1367320.html</a></p><p>【原作者】阿里云</p></blockquote><ul><li><p>摘要：HTTP是一个属于应用层的超文本传输协议(HTTP,HyperTextTransferProtocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。TCP(TransmissionControlProtocol传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。采用三次握手确认建立一个连接。我们说的http的三次握手,其实是TCP的三次握手:TCP通过发送位码来判断一个连接建立的状态,位码就是一个标识位,有6种:SYN(synch</p></li><li><p>HTTP是一个属于应用层的超文本传输协议(HTTP,HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。<br>TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议。采用三次握手确认建立一个连接。<br>我们说的http的三次握手,其实是TCP的三次握手:<br>TCP通过发送位码来判断一个连接建立的状态,位码就是一个标识位,有6种:</p><ol><li>SYN(synchronous建立联机)</li><li>ACK(acknowledgement 确认)</li><li>PSH(push传送)</li><li>FIN(finish结束)</li><li>RST(reset重置)</li><li>URG(urgent紧急)</li></ol></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/csdn/2eee9d45-9a6f-43d6-939b-8a50c33d7fce?x-oss-process=image/resize,p_100/auto-orient,1/quality,q_90/format,jpg/watermark,image_eXVuY2VzaGk=,t_100,g_se,x_0,y_0" alt="img"></p><p>第一次握手:主机A发送位码为SYN = 1,同时随机生成一个seq number=1253234的数据包到服务器,主机B由SYN=1知道,A要求联机;</p><p>第二次握手:主机B收到请求后要确认联机信息,向主机A发送 ACK number = (主机A的seq+1),SYN = 1,ACK = 1,随机产生seq = 7867867的包;</p><p>第三次握手:主机A收到后检查ACK number是否正确,即第一次发送的seq number+1以及ACK是否为1,若正确,主机A会再发送ACK number= (主机B的seq+1),ACK=1,主机B收到后确认seq值与ACK=1则建立连接。</p><p>至此三次握手完成,连接建立成功。</p><p>这一过程内部大概是这样的,第一次握手,主机A发送SYN(SYN=J)包到服务器,并进入SYN_SEND状态,等待服务器确认;<br>第二次握手,服务器收到SYN包,必须确认主机A的SYN值为1,即要建立连接,同时自己发送一个SYN包给主机A,SYN(SYN = K),即SYN+ACK包,此时服务器进入SYN_RECV状态,<br>第三次握手,客户端收到客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ACK = K+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手,开始传送数据。</p><p>例子:<br>ip 192.168.1.21:3685 –&gt; 192.168.1.122:6656 S 456523354<br>ip 192.168.1.122:6656 –&gt; 192.168.1.21:3685 S 348983483: 348983483 ACK 456523355<br>ip 192.168.1.21:3685 –&gt; 192.168.1.122:6656 ACK 348983484,ACK 1</p><p>第一次握手:192.168.1.21发送位码 SYN = 1,随机产生seq number = 456523354<br>的数据包到192.168.1.122 由SYN = 1知道192.168.1.21要求建立联机<br>第二次握手:192.168.1.122收到请求后要确认联机信息,向192.168.1.21发送ACK number = 456523355,SYN = 1,ACK = 1,随机产生的seq = 348983483的包</p><p>第三次握手:192.168.1.21收到数据包检查 ACK num是否等于第一次发送的seq+1,以及ACK是否为1,若正确,会再次发送ack number = 348983484,ack =1的包给192.168.1.122<br>192.168.1.122收到后确认seq = seq+1,ack=1则连接建立成功。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>其实 就是对应的断开的过程:<br>1.客户端请求断开连接:FIN = 1, seq = u;<br>2.服务端对客户端的请求响应:ACK = 1,seq = v,ack = u+1;<br>3.服务端请求断开连接:FIN = 1,ACK =1,seq = w,ack = u+1;<br>4.客户端对服务端的请求响应:ACK=1,seq = u+1,ack = w+1;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>现在回想起来，当初学计算机网络原理的时候，简直就是死记硬背应付考试。以上大多是转载留作自己的学习资料，懒得以后到处翻。嘛，就这样吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;哎，本来今天是想写一篇关于go语言的学习笔记的，但是想想还是算了吧，本来自己领域里面的东西都还是半吊子，
      
    
    </summary>
    
      <category term="rpc" scheme="http://bandao.ink/categories/rpc/"/>
    
      <category term="http" scheme="http://bandao.ink/categories/rpc/http/"/>
    
      <category term="计算机网络" scheme="http://bandao.ink/categories/rpc/http/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://bandao.ink/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="rpc" scheme="http://bandao.ink/tags/rpc/"/>
    
      <category term="http" scheme="http://bandao.ink/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>Linux搭建shadowsocks访问外网</title>
    <link href="http://bandao.ink/2018/11/16/Linux%E6%90%AD%E5%BB%BAshadowsocks/"/>
    <id>http://bandao.ink/2018/11/16/Linux搭建shadowsocks/</id>
    <published>2018-11-16T07:37:29.000Z</published>
    <updated>2018-11-16T08:25:05.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>特此备注本文文章内容</p><p>转自原链接：<a href="http://blog.51cto.com/13756513/2118075" target="_blank" rel="noopener">http://blog.51cto.com/13756513/2118075</a></p><p>原作者：vpsceping</p><p>因为现在国内对这个东西查得很严，百度上面相关的东西都被封杀了，这篇文章也是google上面搜索到的。为避免以后原作者删除和无外网环境的情况，自己转载一下留作备忘。</p></blockquote><p>本文从零开始，手把手教你搭建自己的shadowsocks代理服务器实现科学上网。可用×××方法，史上最全的小白搭建ss教程。内容包括VPS购买，连接VPS，一键搭建shadowsocks，开启bbr加速，客户端配置shaodowsocks。</p><h2 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>VPS（Virtual private server，虚拟专用服务器），个人用来搭建一些博客，跑跑脚本足够了。今天的教程就用VPS来搭建属于自己的shaodowsocks，一个人独占一条线路。</p><p><strong>Vultr</strong>是美国的一个VPS服务商，全球有15个数据中心，可以一键部署服务器。采用<strong>小时计费策略</strong>，可以在任何时间新建或者摧毁VPS。价格低廉，最便宜的只要2.5一个月，<strong>支持支付宝</strong>。</p><h3 id="新用户注册"><a href="#新用户注册" class="headerlink" title="新用户注册"></a>新用户注册</h3><p>优惠注册链接：<a href="https://yhgo.wang/vultr" target="_blank" rel="noopener">www.vultr.com</a></p><p><img src="http://i2.51cto.com/images/blog/201809/14/81bef230ac147336c147f030324400f8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>填写邮箱、密码（至少10个字符，并且有<strong>一个大写字母&amp;一个小写字母&amp;一个数字</strong>），最后点击后面的Create Account即可。注册完会收到一封验证邮件，验证即可~</p><h3 id="充值"><a href="#充值" class="headerlink" title="充值"></a>充值</h3><p>Vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可~而费用计算是从你开通时开始计算的，不管你有没有使用都会扣费，即使你处于关机状态，唯一停止计费的方法是Destroy掉这个服务器！Vultr提供的服务器配置包括：</p><p>2.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 100M带宽 500G流量/月</p><p>5美元/月的服务器配置信息：单核 1G内存 25G SSD硬盘 100M带宽 1000G流量/月</p><p>10美元/月的服务器配置信息：单核 2G内存 40G SSD硬盘 100M带宽 2000G流量/月</p><p>20美元/月的服务器配置信息：2cpu 4G内存 60G SSD硬盘 100M带宽 3000G流量/月</p><p>40美元/月的服务器配置信息：4cpu 8G内存 100G SSD硬盘 100M带宽 4000G流量/月</p><p>验证并登录后我们会跳转到充值界面，或者从<strong>Billing</strong>-&gt;<strong>Make Patment</strong>进入：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/24bf5b457caccd7601e2cc3679f4fca7.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>支持支付宝，充值10刀，按小时扣费，只要保证账户有余额，你的服务器就会一直运行。</p><h3 id="新机器创建"><a href="#新机器创建" class="headerlink" title="新机器创建"></a>新机器创建</h3><p>选择右上角的蓝色+号按钮，进入<strong>Deploy</strong>页面，选择服务器配置：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/69660b6949314761b16cd1d8f3af9b96.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>目前2.5的还有<strong>迈尔密</strong>和<strong>纽约</strong>的没有售罄，对于ping值和速度要求不是特别高的可以选择这里的（毕竟美国东海岸城市，离国内有点远）~</p><p>推荐服务器使用<strong>洛杉矶</strong>的~</p><p>之后在<strong>Additional Features</strong>中勾选<strong>Enable IPv6</strong>:</p><p><img src="http://i2.51cto.com/images/blog/201809/14/f154414e732dad8add4e12af1eff1878.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>其他都直接默认即可，最后点击右下角的<strong>Deploy Now</strong>开始新建。</p><h3 id="获取VPS登录信息"><a href="#获取VPS登录信息" class="headerlink" title="获取VPS登录信息"></a>获取VPS登录信息</h3><p>选择Deploy后，过个几分钟，就可以看到自己的服务器信息了，具体位置在<strong>Servers</strong>-&gt;<strong>Instances</strong>，点击选择你新建的实例：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/8c4c207cfb0dbc6b17e1f491646117b4.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>其中，红框选中的部分从上到下依次是IP，用户名和密码~</p><h2 id="连接VPS"><a href="#连接VPS" class="headerlink" title="连接VPS"></a>连接VPS</h2><h3 id="Windows连接VPS"><a href="#Windows连接VPS" class="headerlink" title="Windows连接VPS"></a>Windows连接VPS</h3><p>1.下载Xsehll</p><p>直接在<a href="http://rj.baidu.com/soft/detail/15201.html?ald" target="_blank" rel="noopener">百度软件中心</a>下载，下载后正常安装即可（如果失效了就去别的地方下一个，很多地方可以下载）~</p><p>2.连接linux</p><p>选择<strong>文件</strong>-&gt;<strong>新建</strong>：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/94293c74d0e93338c1a50b4308da29b1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>在主机位置输入你的VPS IP：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/4396ffc11fe8db89f201012f234369b9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>确定后会让你输入你的Linux用户名：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/8941136aeb7b7ce29ff45054c1f62231.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>之后是Linux用户密码：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/40f3fd5afa2021ec93fda9f1ee8c42cb.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>如果显示如下图所示就表示连接成功了（如果是Vultr，那么连接成功标志应该是root@vultr）：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/f758dc1f9834eb13a5e3b1fdd6b5917f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><h3 id="Mac-OS连接VPS"><a href="#Mac-OS连接VPS" class="headerlink" title="Mac OS连接VPS"></a>Mac OS连接VPS</h3><p>直接打开Terminal终端，输入：ssh <a href="mailto:root@43.45.43.21" target="_blank" rel="noopener">root@43.45.43.21</a>，之后输入你的密码就可以登录了（输入密码的时候屏幕上不会有显示）</p><p><img src="http://i2.51cto.com/images/blog/201809/14/58501f8c5cca741a8c272adca44391fe.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><h2 id="一键搭建shaodowsocks-shadowsocksR"><a href="#一键搭建shaodowsocks-shadowsocksR" class="headerlink" title="一键搭建shaodowsocks/shadowsocksR"></a>一键搭建shaodowsocks/shadowsocksR</h2><p>注意，shadowsocks/shadowsocksR这两个<strong>只需要搭建一个</strong>就可以了！！！！SS与×××之间的比较一直是各有各的说法，王婆卖瓜自卖自夸。我用的是SS，因为SS的iOS版本比较容易下载，并且被没有觉得ss容易被探查到~</p><h3 id="一键搭建shadowsocks"><a href="#一键搭建shadowsocks" class="headerlink" title="一键搭建shadowsocks"></a>一键搭建shadowsocks</h3><p>1.下载git</p><p>代码放在github上，因此需要通过git命令同步，复制以下代码回车（这里针对刚刚新建时选择的是Ubuntu的用户，如果你是Centos，则用命令<code>yum -y install git</code>安装）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y git</span><br></pre></td></tr></table></figure><p><img src="http://i2.51cto.com/images/blog/201811/08/dcca9589b8ac7716a4aeccbe2219e250.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"><br>2.下载一键搭建ss脚本文件（直接复制这段代码运行即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure><p><img src="http://i2.51cto.com/images/blog/201809/14/cd933727572f1a7e07997d6b333db65d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>3.运行搭建ss脚本代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -i flyzy2005.com 1024</span><br></pre></td></tr></table></figure><p>其中<strong>flyzy2005.com</strong>换成你要设置的shadowsocks的密码即可（这个<strong>flyzy2005.com</strong>就是你ss的密码了，是需要填在客户端的密码那一栏的），密码随便设置，最好<strong>只包含字母+数字</strong>，一些特殊字符可能会导致冲突。而第二个参数1024是<strong>端口号</strong>，也可以不加，不加默认是1024~（<strong>举个例子</strong>，脚本命令可以是ss-fly/ss-fly.sh -i qwerasd，也可以是ss-fly/ss-fly.sh -i qwerasd 8585，后者指定了服务器端口为8585，前者则是默认的端口号1024，两个命令设置的ss密码都是qwerasd）：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/f3291107e12e2355070372fe44cd608b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>出现如下界面就说明搭建好了：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/d573979b523abef7df9b97e6a69d71b5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p><strong>注</strong>：如果需要改密码或者改端口，只需要重新再执行一次<strong>搭建ss脚本代码</strong>就可以了，或者是修改<code>/etc/shadowsocks.json</code>这个配置文件，之后重启ss服务。</p><p>4.相关ss操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改配置文件：vim /etc/shadowsocks.json</span><br><span class="line">停止ss服务：ssserver -c /etc/shadowsocks.json -d stop</span><br><span class="line">启动ss服务：ssserver -c /etc/shadowsocks.json -d start</span><br><span class="line">重启ss服务：ssserver -c /etc/shadowsocks.json -d restart</span><br></pre></td></tr></table></figure><p>5.卸载ss服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -uninstall</span><br></pre></td></tr></table></figure><h3 id="一键搭建shadowsocksR"><a href="#一键搭建shadowsocksR" class="headerlink" title="一键搭建shadowsocksR"></a>一键搭建shadowsocksR</h3><p><strong>再次提醒</strong>，如果安装了SS，就不需要再安装×××了，如果要改装×××，请按照上一部分内容的教程先卸载SS！！！</p><p>1.下载git</p><p>代码放在github上，因此需要通过git命令同步，复制以下代码回车（这里针对刚刚新建时选择的是Ubuntu的用户，如果你是Centos，则用命令<code>yum -y install git</code>安装）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y git</span><br></pre></td></tr></table></figure><p><img src="http://i2.51cto.com/images/blog/201811/08/dcca9589b8ac7716a4aeccbe2219e250.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>2.下载一键搭建<strong>脚本（只需要执行一次，卸载</strong>后也不需要重新执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/flyzy2005/ss-fly</span><br></pre></td></tr></table></figure><p>3.运行搭建***脚本代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -***</span><br></pre></td></tr></table></figure><p><img src="http://i2.51cto.com/images/blog/201809/14/7ac912027b7dcaed35c89b844ae931a5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>4.输入对应的参数</p><p>执行完上述的脚本代码后，会进入到输入参数的界面，包括服务器端口，密码，加密方式，协议，混淆。可以直接输入回车选择默认值，也可以输入相应的值选择对应的选项：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/640b62bb8594da77ba22b44388420f5e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>全部选择结束后，会看到如下界面，就说明搭建***成功了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, ShadowsocksR server install completed!</span><br><span class="line">Your Server IP        :你的服务器ip</span><br><span class="line">Your Server Port      :你的端口</span><br><span class="line">Your Password         :你的密码</span><br><span class="line">Your Protocol         :你的协议</span><br><span class="line">Your obfs             :你的混淆</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://shadowsocks.be/9.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>5.相关操作***命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动：/etc/init.d/shadowsocks start</span><br><span class="line">停止：/etc/init.d/shadowsocks stop</span><br><span class="line">重启：/etc/init.d/shadowsocks restart</span><br><span class="line">状态：/etc/init.d/shadowsocks status</span><br><span class="line"></span><br><span class="line">配置文件路径：/etc/shadowsocks.json</span><br><span class="line">日志文件路径：/var/log/shadowsocks.log</span><br><span class="line">代码安装目录：/usr/local/shadowsocks</span><br></pre></td></tr></table></figure><p>6.卸载***服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocksR.sh uninstall</span><br></pre></td></tr></table></figure><h2 id="一键开启BBR加速"><a href="#一键开启BBR加速" class="headerlink" title="一键开启BBR加速"></a>一键开启BBR加速</h2><p>BBR是Google开源的一套内核加速算法，可以让你搭建的shadowsocks/shadowsocksR速度上一个台阶，本一键搭建ss/***脚本支持一键升级最新版本的内核并开启BBR加速。</p><p>BBR支持4.9以上的，如果低于这个版本则会自动下载最新内容版本的内核后开启BBR加速并重启，如果高于4.9以上则自动开启BBR加速，执行如下脚本命令即可自动开启BBR加速：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-fly/ss-fly.sh -bbr</span><br></pre></td></tr></table></figure><p><img src="http://i2.51cto.com/images/blog/201809/14/4092ffff044c88fc5ed5d99516e4ddb1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>装完后需要重启系统，输入y即可立即重启，或者之后输入reboot命令重启。</p><p>判断BBR加速有没有开启成功。输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>如果返回值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure><p>后面有bbr，则说明已经开启成功了。</p><h2 id="本机配置shadowsocks"><a href="#本机配置shadowsocks" class="headerlink" title="本机配置shadowsocks"></a>本机配置shadowsocks</h2><p>各版本的shadowsocks客户端下载地址可以参考：<a href="https://www.flyzy2005.com/fan-qiang/shadowsocks/ss-clients-download/" target="_blank" rel="noopener">Android/Windows/iOS/Mac/Linux shadowsocks客户端下载地址</a>（打不开就去github搜，或者直接百度搜下载地址）</p><h3 id="WIndows客户端配置"><a href="#WIndows客户端配置" class="headerlink" title="WIndows客户端配置"></a>WIndows客户端配置</h3><p>双击运行shadowsocks.exe，之后会在任务栏有一个小飞机图标，右击小飞机图标，选择<strong>服务器</strong>-&gt;<strong>编辑服务器</strong>：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/4e410b6d1da170a9adb03f6d26b3750a.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>在shadowsocks的windows客户端中，<strong>服务器IP</strong>指你购买的VPS的IP，<strong>服务器端口</strong>指你服务器的配置文件中的端口，<strong>密码</strong>指你服务器的配置文件中的密码，<strong>加密</strong>指你服务器的配置文件中的加密方式，<strong>代理端口</strong>默认为1080不需要改动。<strong>其他都可以默认</strong>。设置好后，点击添加按钮即可。</p><h3 id="MAC-OS客户端配置"><a href="#MAC-OS客户端配置" class="headerlink" title="MAC OS客户端配置"></a>MAC OS客户端配置</h3><p>双击运行shadowsocksX-NG.app，之后会在任务栏有一个小飞机图标，右击小飞机图标，选择<strong>服务器</strong>-&gt;<strong>服务器设置</strong>：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/8bad23fd08194e02b06a0b3025433a06.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>在shadowsocks的Mac OS客户端中，<strong>地址</strong>指你购买的VPS的IP，冒号后面跟上配置文件中的<strong>端口</strong>，<strong>密码</strong>指你服务器的配置文件中的密码，<strong>加密</strong>指你服务器的配置文件中的加密方式。<strong>其他都可以默认</strong>。设置好后，点击确认即可。</p><h3 id="安卓客户端配置"><a href="#安卓客户端配置" class="headerlink" title="安卓客户端配置"></a>安卓客户端配置</h3><p>下载apk安装好后，打开影梭客户端，点击主界面左上角的<strong>编辑按钮</strong>（铅笔形状）：</p><p><img src="http://i2.51cto.com/images/blog/201809/14/bffb3fac8049e77dad5d02c94834a317.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><p>在shadowsocks安卓客户端的配置中填入相应配置信息，其中，<strong>功能设置</strong>中，<strong>路由</strong>改成如上图所示，其他都可以默认。</p><h3 id="苹果客户端配置"><a href="#苹果客户端配置" class="headerlink" title="苹果客户端配置"></a>苹果客户端配置</h3><p>shadowsocks苹果客户端经常会被App Store下架，可以在App Store搜索关键字<strong>shadowsock</strong>或者<strong>wingy</strong>，找到一个软件截图中包括填写ip，加密方式，密码的软件一般就是对的了（目前可以用的是FirstWingy）。当然，你也可以下载PP助手，之后在PP助手上下载Wingy（Wingy支持<strong>）或者shadowrocket（shadowrocket支持</strong>）。</p><p><img src="http://i2.51cto.com/images/blog/201809/14/e676114cffefabf93366309f0d7c2340.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="手把手教你搭建shadowsocks科学上网 搭建ss教程"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如上就是手把手教你搭建shadowsocks的全部内容。在国内，***是不允许的了，所以还不如自己搭建ss，可以独享一个线路。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;特此备注本文文章内容&lt;/p&gt;
&lt;p&gt;转自原链接：&lt;a href=&quot;http://blog.51cto.com/13
      
    
    </summary>
    
      <category term="linux" scheme="http://bandao.ink/categories/linux/"/>
    
    
      <category term="centos" scheme="http://bandao.ink/tags/centos/"/>
    
      <category term="linux" scheme="http://bandao.ink/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS上安装nginx</title>
    <link href="http://bandao.ink/2018/11/14/CentOS%E4%B8%8A%E5%AE%89%E8%A3%85nginx/"/>
    <id>http://bandao.ink/2018/11/14/CentOS上安装nginx/</id>
    <published>2018-11-14T01:03:09.961Z</published>
    <updated>2018-11-14T01:03:09.961Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>呃，之前双十一阿里云打折，然后加了一个团购团，直接折上折，平时100多大洋/月的服务器，然后我300块买了三年/手动滑稽。马爸爸可真是财大气粗啊，哈哈。于是准备之后在这台服务器上部署自己的博客网站和老爸店里的网站，开始做准备工作吧～</p></blockquote><hr><p><em>Nginx</em> (engine x) 是一个高性能的HTTP和反向代理服务，同时也是一款轻量级的Web服务器。优点是占有内存少，并发能力强。我一般把它用来当做网页服务器容器。话不多说，开始上手。</p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><h2 id="下载tar包"><a href="#下载tar包" class="headerlink" title="下载tar包"></a>下载tar包</h2><h3 id="创建存放路径"><a href="#创建存放路径" class="headerlink" title="创建存放路径"></a>创建存放路径</h3><ol><li>cd /usr/local</li><li>mkdir nginx</li><li>cd nginx</li></ol><h3 id="下载tar包-1"><a href="#下载tar包-1" class="headerlink" title="下载tar包"></a>下载tar包</h3><blockquote><p>这里我们使用wget来下载网络上的tar包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.13.7.tar.gz</span><br></pre></td></tr></table></figure><ul><li>如果提示找不到命令，说明我们的服务器上还没有装wget，使用yum装之</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><ul><li>然后我们解压tar包到当前目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nginx-1.13.7.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><ol><li>cd /usr/local/nginx  进入nginx目录</li><li>./configure  执行配置</li><li>make  编译</li><li>make install  安装</li></ol><p>OK！等待安装完毕就可以使用了</p><h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>利用vim编辑器修改配置，指定项目路径配置端口即可</li></ul><p>示例（写到http{}里面）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       8787;</span><br><span class="line">server_name  192.168.10.249;</span><br><span class="line">location / &#123;</span><br><span class="line">        root   crm\dist;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>listen：访问端口</li><li>server_name：服务器ip</li><li>location/root： 项目存放根目录（index目录）</li><li>location/index： 网页入口</li></ul><h3 id="启动-停止-重启"><a href="#启动-停止-重启" class="headerlink" title="启动/停止/重启"></a>启动/停止/重启</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">启动 ./nginx -c /usr/local/nginx/conf/nginx.conf </span><br><span class="line">停止 ./nginx -s stop</span><br><span class="line">重启 ./nginx -s restart</span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/centos/n2.png" alt="images"></p><p>完毕，收工！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Nginx作为web服务器还是非常强大的，可谓简单易用。借用同学的一句话。内事不决问百度，外事不决问谷歌，此乃恒久之道也。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;呃，之前双十一阿里云打折，然后加了一个团购团，直接折上折，平时100多大洋/月的服务器，然后我300块买
      
    
    </summary>
    
      <category term="linux" scheme="http://bandao.ink/categories/linux/"/>
    
      <category term="nginx" scheme="http://bandao.ink/categories/linux/nginx/"/>
    
    
      <category term="centos" scheme="http://bandao.ink/tags/centos/"/>
    
      <category term="linux" scheme="http://bandao.ink/tags/linux/"/>
    
      <category term="nginx" scheme="http://bandao.ink/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动化管理hexo</title>
    <link href="http://bandao.ink/2018/11/12/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86hexo/"/>
    <id>http://bandao.ink/2018/11/12/Jenkins自动化管理hexo/</id>
    <published>2018-11-12T15:33:29.000Z</published>
    <updated>2018-11-20T02:16:55.353Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>前两天把自己以前搭的博客弄到服务器上面丢到了nginx里面。但是问题是，每次自己要发布博客时，难道都要重新打一个包发到服务器上面解压缩。就在想能不能我每次提交后，让服务器执行一个shell脚本实现动态刷新。思来想去，好像jenkins能实现这种场景，于是乎，撸起袖子开干吧～</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><strong><em>先说一下我的思路。</em></strong>我平时一般在Mac上面用markdown写博客，然后push到github上去。然后服务器上面装好git后将项目clone下来，再利用jenkins检测到我push后，执行shell脚本去pull博客代码。因为项目是丢在nginx里面，pull后就可以直接看到更新后的内容了。</li></ul><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j4.png" alt="images"></p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>服务器需要安装git来动态pull博客代码，直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><h3 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h3><p>1.这里我是安装的最新版，命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure><p>2.启动jenkins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure><p>jenkins的默认端口号是8080，现在打开浏览器输入你的ip地址加上8080端口即可出现如下画面</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j5.png" alt="images"></p><p>3.按照提示找到对应目录下的密码复制上去即可，查看命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><p>4.选择默认插件安装，最新版本是带了Git相关的插件的，安装即用</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/jstart.png" alt="images"></p><p>5.后面就是添加管理员巴拉巴拉的，最后进入初始页面，准备创建一个新的任务</p><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><ul><li>好了，准备工作做完我们开始正题</li></ul><h3 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h3><p>首先创建一个新的任务，选择第一个选项，构建一个自由风格的软件项目</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j6.png" alt="images"></p><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>目的是为了让jenkins从对应仓库拉取代码</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j7.png" alt="images"></p><h3 id="配置触发器"><a href="#配置触发器" class="headerlink" title="配置触发器"></a>配置触发器</h3><p>这里选择轮询（poll）SCM，下面是一个定时器的cron表达式，这里是指每隔十分钟运行一次当前任务</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j8.png" alt="images"></p><h3 id="配置shell"><a href="#配置shell" class="headerlink" title="配置shell"></a>配置shell</h3><p>最后配置shell脚本，跟我们之前提到的一样，这里只需要到你的博客代码指定的地方（nginx映射的路径[使用方式和安装可查看我的博客「CentOS上安装nginx」]， 如下一图），pull一下代码即可，如下二图</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j9.png" alt="images"></p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j10.png" alt="images"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>好了，最后我们可以运行这个任务了</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j11.png" alt="images"></p><p>我们点进入进去看到里面的构建历史记录</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j12.png" alt="images"></p><p>OK!成功后就是下面的样子，如果错误，就根据控制台打印的日志，具体问题具体分析。</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j14.png" alt="images"></p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="无权限"><a href="#无权限" class="headerlink" title="无权限"></a>无权限</h3><p>当时遇到的第一个问题就是没有权限执行某个具体的操作，控制台包如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxx Permission denied</span><br><span class="line">Build step &apos;执行 shell&apos; marked build as failure</span><br><span class="line">Finished: FAILURE</span><br></pre></td></tr></table></figure><blockquote><p>之前在网上查了很久，无非就是说权限有问题，让我把jenkins目录的权限设大，还有什么用sudo来启动jenkins，但是都没有用，无奈问了下哥们，最终定位到是配置文件用户组权限的问题。</p></blockquote><p>这个问题其实很简单，让我们先看看jenkins的配置文件。先看看jenkins相关路径，命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql jenkins</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j15.png" alt="images"></p><p>ok，定位到路径，vim之</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j16.png" alt="images"></p><p>可以看到我们配置文件里，默认jenkins使用的用户一个名为‘jenkins’的用户，如果你用 cat /etc/passwd 就可以看见‘jenkins’这个用户对应的权限，是没有我们设定目录的权限的。现在有两种方案可行：</p><ol><li>将上图的‘JENKINS_USER’对应的value改为root，什么都解决了，包括之后的问题。意味着jenkins拥有root最高权限。但是缺点是听说之前老版本的jenkins是有安全漏洞的，要是有人把你的jenkins搞了，然后就可以利用jenkins在你服务器上执行一些脚本，emmm细思极恐</li><li>将我们要操作的目录，也就是上面配置的博客目录/home/blog/bandao的权限赋给‘jenkins’这个用户，执行下面的命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R jenkins[用户名]:jenkins [这是组名]/home/blog/bandao</span><br></pre></td></tr></table></figure><p>这里解释一下， chmod能改变权限，-R是目录下所有文件，对目前目录下的所有档案与子目录进行相同的拥有者变更(即以递回的方式逐个变更) </p><p>ok，这个问题解决！</p><h3 id="git-pull主机密钥验证失败"><a href="#git-pull主机密钥验证失败" class="headerlink" title="git pull主机密钥验证失败"></a>git pull主机密钥验证失败</h3><p>来来，这是刚刚构建很容易出现的问题，除非你像刚刚上面第一个坑那样把jenkins的配置文件的用户改为root，否则就出现下面这个错误</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j17.png" alt="images"></p><p>大概的意思就是主机无权限，无法读取远程仓库。嘿，我当时就纳闷了，我手动pull是没问题的啊，而且我github都设置了ssh-key的啊。后来发现，特么我进去是root用户，肯定没问题啊。报这个错本质上说的还是‘jenkins’这个用户没有权限访问远程仓库！</p><p>ok，定位到问题就好办。首先切换成’jenkins‘这个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash jenkins</span><br></pre></td></tr></table></figure><p>第二步生成专属于‘jenkins’用户的ssh-key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa 后一路回车</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>第三步复制上面cat出来的公钥到github</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j18.png" alt="images"></p><p>现在试试用‘jenkins’用户 pull一下</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/jenkins/j19.png" alt="images"></p><p>搞定，收工！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>晚上和以前的前辈喝了酒，回来突然想把这篇博客写了，头晕昏昏的，写了两个多小时，记录一下自己踩的坑，备忘。嘛，喝瓶哇哈哈，继续嗨～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前两天把自己以前搭的博客弄到服务器上面丢到了nginx里面。但是问题是，每次自己要发布博客时，难道都要重
      
    
    </summary>
    
      <category term="jenkins" scheme="http://bandao.ink/categories/jenkins/"/>
    
      <category term="hexo" scheme="http://bandao.ink/categories/jenkins/hexo/"/>
    
    
      <category term="centos" scheme="http://bandao.ink/tags/centos/"/>
    
      <category term="linux" scheme="http://bandao.ink/tags/linux/"/>
    
      <category term="jenkins" scheme="http://bandao.ink/tags/jenkins/"/>
    
      <category term="hexo" scheme="http://bandao.ink/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux利用SSH免密登陆和设置别名</title>
    <link href="http://bandao.ink/2018/11/12/Linux%E5%88%A9%E7%94%A8SSH%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8D/"/>
    <id>http://bandao.ink/2018/11/12/Linux利用SSH免密登陆和设置别名/</id>
    <published>2018-11-12T15:24:27.735Z</published>
    <updated>2018-11-12T15:24:27.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>小公司啊，本职开发兼职运维、DBA。欲哭无泪/摊手。嘛，祸兮福所倚，借此机会，学习一波Linux。</p></blockquote><p>之前用Linux的时候，总觉得ssh连接服务器的时候每次都要输入密码，开始觉得还好，但是由于分布式项目，每次都要来回切换各种内网服务器，输入密码的频率极高。秉承“懒”的极致，学习了ssh免密登陆和设置别名。</p><h2 id="SSH免密登陆"><a href="#SSH免密登陆" class="headerlink" title="SSH免密登陆"></a>SSH免密登陆</h2><ul><li>假设现在有两台机器A和B，现在B机器想免密登陆A</li></ul><h3 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh-key"></a>生成ssh-key</h3><p>1.首先先在B机器生成一个ssh-key，如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa  然后一路回车</span><br></pre></td></tr></table></figure><ul><li>备注：若提示找不到ssh-keygen命令，说明本机未安装git client；利用yum安装之</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>1.后将生成的公钥复制到A机器～/.ssh/authorized_keys 中，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@A机器ip</span><br></pre></td></tr></table></figure><p>2.现在直接连接服务器吧 ssh root@ip</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/centos/l2.png" alt="images"></p><h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><ul><li>Linux中有时候命令过长是可以设置别名偷哈懒</li></ul><ol><li>alias  查看当前别名列表</li><li>设置别名<ul><li>临时生效（作用于当前回话）：alias [别名]=‘[具体命令]’  如 alias ll=‘ls -ll’</li><li>永久生效：修改根目录~/.bashrc；利用vim编辑器修改；mac里面是~/.bash_profile;   修改完后source ~/.bash_profile生效;下图以mac为例</li></ul></li></ol><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/centos/l3.png" alt="images"></p><h3 id="简化ssh"><a href="#简化ssh" class="headerlink" title="简化ssh"></a>简化ssh</h3><ul><li>有了别名，我们就可以简化我们的ssh连接了，参照3.1简化你的连接吧</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>Linux还是得系统学一遍呀，感觉挺有意思的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;小公司啊，本职开发兼职运维、DBA。欲哭无泪/摊手。嘛，祸兮福所倚，借此机会，学习一波Linux。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="linux" scheme="http://bandao.ink/categories/linux/"/>
    
      <category term="ssh" scheme="http://bandao.ink/categories/linux/ssh/"/>
    
    
      <category term="centos" scheme="http://bandao.ink/tags/centos/"/>
    
      <category term="linux" scheme="http://bandao.ink/tags/linux/"/>
    
      <category term="ssh" scheme="http://bandao.ink/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Mac神器-brew安装和使用</title>
    <link href="http://bandao.ink/2018/11/10/Mac%E7%A5%9E%E5%99%A8-brew%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://bandao.ink/2018/11/10/Mac神器-brew安装和使用/</id>
    <published>2018-11-10T02:31:29.000Z</published>
    <updated>2018-11-12T15:24:27.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>最近自考完，紧绷的神经算是得以放松，也算告一段落了。之前呢，对macOS憧憬已久，用了一周后，感觉进入了新世界，视网膜屏幕、优秀的后台管理机制、完爆windows的终端和触摸板。噫，真香～ </p></blockquote><h2 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h2><p>说到mac的终端，就不得不说到brew，mac下的一个包管理工具。其功能类似于centOS的yum和ubuntu的apt-get。有了它后就再也不用到处找资源装环境了，一句命令解决之！</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开mac终端输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>备注：如果这里提示当前目录不存在，直接回车即创建</p><p>目录：</p><ol><li>brew 安装目录 /usr/local/Cellar</li><li>brew 配置目录 /usr/local/etc</li><li>brew 命令目录 /usr/local/bin </li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p>update brew    更新brew</p></li><li><p>brew install [应用名字，如nodejs]    安装环境</p><p>示例：</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/mac/ter2.png" alt="images"></p></li><li><p>brew list    查看当前安装的列表n</p></li><li><p>brew uninstall [应用名]    卸载应用</p></li><li><p>brew services [command] {应用名}    利用brew来执行应用服务命令</p><p><em>以启动/停止nginx为例</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brew services start/stop/restart nginx</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/mac/ter4.png" alt="images"></p><p><em>启动成功，正常访问：</em></p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/mac/ter5.png" alt="images"></p></li><li><p>brew info [应用名字 ]    查看应用安装信息，如安装路径；命令路径等</p><p><img src="https://gitee.com/creator_eyw/static/raw/master/img/mac/ter3.png" alt="images"></p><p>以上只是一些常用的功能，更多用法用brew help来查看吧～</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>其实brew不帮助你装了软件，还帮你配置了各类环境变量。如此神器，还不快快使用！</p></blockquote><p>人老了，也健忘，意识到写博客的重要性。人生路漫漫，还需加倍的努力啊。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;最近自考完，紧绷的神经算是得以放松，也算告一段落了。之前呢，对macOS憧憬已久，用了一周后，感觉进入了新世界，视
      
    
    </summary>
    
      <category term="mac" scheme="http://bandao.ink/categories/mac/"/>
    
      <category term="brew" scheme="http://bandao.ink/categories/mac/brew/"/>
    
    
      <category term="mac" scheme="http://bandao.ink/tags/mac/"/>
    
      <category term="brew" scheme="http://bandao.ink/tags/brew/"/>
    
  </entry>
  
  <entry>
    <title>北岛以北，樱花绽</title>
    <link href="http://bandao.ink/2018/05/02/dream/"/>
    <id>http://bandao.ink/2018/05/02/dream/</id>
    <published>2018-05-02T03:52:29.000Z</published>
    <updated>2018-11-11T02:22:54.314Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/creator_eyw/static/raw/master/img/g6.jpg" alt="images"><br><img src="https://gitee.com/creator_eyw/static/raw/master/img/g7.jpg" alt="images"><br><img src="https://gitee.com/creator_eyw/static/raw/master/img/g1.jpg" alt="images"><br><img src="https://gitee.com/creator_eyw/static/raw/master/img/g2.jpg" alt="images"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://gitee.com/creator_eyw/static/raw/master/img/g6.jpg&quot; alt=&quot;images&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://gitee.com/creator_eyw/static/raw
      
    
    </summary>
    
    
  </entry>
  
</feed>
